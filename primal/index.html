<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `primal` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, primal">

    <title>primal - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'primal', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>primal</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/primal/src/lib.rs.html#1-293' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p><code>primal</code> puts raw power into prime numbers.</p>

<p>This crates includes</p>

<ul>
<li>optimised prime sieves</li>
<li>checking for primality</li>
<li>enumerating primes</li>
<li>factorising numbers</li>
<li>estimating upper and lower bounds for π(<em>n</em>) (the number of primes
below <em>n</em>) and <em>p<sub>k</sub></em> (the <i>k</i>th prime)</li>
</ul>

<p>This uses a state-of-the-art cache-friendly Sieve of Eratosthenes
to enumerate the primes up to some fixed bound (in a memory
efficient manner), and then allows this cached information to be
used for things like enumerating and counting primes.</p>

<p><code>primal</code> takes around 2.8 seconds and less than 3MB of RAM to
count the exact number of primes below 10<sup>10</sup> (455052511)
on my laptop (i7-3517U).</p>

<p><a href="http://github.com/huonw/primal"><em>Source</em></a></p>

<h1 id='using-this-library' class='section-header'><a href='#using-this-library'>Using this library</a></h1>
<p>Just add the following to your <a href="http://crates.io/"><code>Cargo.toml</code></a>:</p>

<pre><code class="language-toml">[dependencies]
primal = &quot;0.2&quot;
</code></pre>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<h2 id='indexing-primes' class='section-header'><a href='#indexing-primes'>&quot;Indexing&quot; Primes</a></h2>
<p>Let&#39;s find the 10001st prime. The easiest way is to enumerate the
primes, and find the 10001st:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// (.nth is zero indexed.)</span>
<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>Primes</span>::<span class='ident'>all</span>().<span class='ident'>nth</span>(<span class='number'>10001</span> <span class='op'>-</span> <span class='number'>1</span>).<span class='ident'>unwrap</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The 10001st prime is {}&quot;</span>, <span class='ident'>p</span>); <span class='comment'>// 104743</span></pre>

<p>This takes around 400 microseconds on my computer, which seems
nice and quick, but, <code>Primes</code> is flexible at the cost of
performance: we can make it faster. The <code>StreamingSieve</code> type
offers a specialised <code>nth_prime</code> function:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>StreamingSieve</span>::<span class='ident'>nth_prime</span>(<span class='number'>10001</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The 10001st prime is {}&quot;</span>, <span class='ident'>p</span>); <span class='comment'>// 104743</span></pre>

<p>This runs in only 10 microseconds! <code>StreamingSieve</code> is extremely
efficient and uses very little memory. It is the best way to solve
this task with <code>primal</code>.</p>

<p>Since that was so easy, let&#39;s now make the problem bigger and
harder: find the sum of the 100,000th, 200,000th, 300,000th, ...,
10,000,000th primes (100 in total).</p>

<p>We could call <code>StreamingSieve::nth_prime</code> repeatedly:</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// the primes we want to find</span>
<span class='kw'>let</span> <span class='ident'>ns</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>100</span> <span class='op'>+</span> <span class='number'>1</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>100_000</span>).<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>();

<span class='comment'>// search and sum them up</span>
<span class='kw'>let</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='ident'>ns</span>.<span class='ident'>iter</span>()
            .<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='ident'>primal</span>::<span class='ident'>StreamingSieve</span>::<span class='ident'>nth_prime</span>(<span class='op'>*</span><span class='ident'>n</span>))
            .<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;the sum is {}&quot;</span>, <span class='ident'>sum</span>);</pre>

<p>This takes around 1.6s seconds to print <code>the sum is 8795091674</code>;
not so speedy. Each call to <code>nth_prime</code> is individually fast (400
microseconds for 100,000 to 40 milliseconds for 10,000,000) but
they add up to something bad. Every one is starting from the start
and redoing work that previous calls have done... wouldn&#39;t it be
nice if we could just do the computation for 10,000,000 and reuse
that for the smaller ones?</p>

<p>The <code>Sieve</code> type is a wrapper around <code>StreamingSieve</code> that
caches information, allowing repeated queries to be answered
efficiently.</p>

<p>There&#39;s one hitch: <code>Sieve</code> requires a limit to know how far to
sieve: we need some way to find an upper bound to be guaranteed to
be at least as large as all our primes. We could guess that, say,
10<sup>10</sup> will be large enough and use that, but that&#39;s a
huge overestimate (spoilers: the 10,000,000th prime is around
2&times;10<sup>8</sup>). We could also try filtering with
exponentially larger upper bounds until we find one that works
(e.g. doubling each time), or, we could just take a shortcut and
use deeper mathematics via
<a href="fn.estimate_nth_prime.html"><code>estimate_nth_prime</code></a>.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>// the primes we want to find</span>
<span class='kw'>let</span> <span class='ident'>ns</span> <span class='op'>=</span> (<span class='number'>1</span>..<span class='number'>100</span> <span class='op'>+</span> <span class='number'>1</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>100_000</span>).<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>();

<span class='comment'>// find our upper bound</span>
<span class='kw'>let</span> (<span class='ident'>_lo</span>, <span class='ident'>hi</span>) <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>estimate_nth_prime</span>(<span class='number'>10_000_000</span>);

<span class='comment'>// find the primes up to this upper bound</span>
<span class='kw'>let</span> <span class='ident'>sieve</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>Sieve</span>::<span class='ident'>new</span>(<span class='ident'>hi</span> <span class='kw'>as</span> <span class='ident'>usize</span>);

<span class='comment'>// now we can efficiently sum them up</span>
<span class='kw'>let</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='ident'>ns</span>.<span class='ident'>iter</span>()
            .<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='ident'>sieve</span>.<span class='ident'>nth_prime</span>(<span class='op'>*</span><span class='ident'>n</span>))
            .<span class='ident'>fold</span>(<span class='number'>0</span>, <span class='op'>|</span><span class='ident'>a</span>, <span class='ident'>b</span><span class='op'>|</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;the sum is {}&quot;</span>, <span class='ident'>sum</span>);</pre>

<p>This takes around 40 milliseconds, and gives the same output: much
better!</p>

<p>(By the way, the version using 10<sup>10</sup> as the bound
instead of the more accurate estimate still only takes ~3
seconds.)</p>

<h2 id='counting-primes' class='section-header'><a href='#counting-primes'>Counting Primes</a></h2>
<p>Another problem: count the number of primes below 1 million. This
is evaluating the <a href="https://en.wikipedia.org/wiki/Prime-counting_function">prime-counting function
π</a>,
i.e. π(10<sup>6</sup>).</p>

<p>As above, there&#39;s a few ways to attack this: the iterator, and the
sieves.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>LIMIT</span>: <span class='ident'>usize</span> <span class='op'>=</span> <span class='number'>1_000_000</span>;

<span class='comment'>// iterator</span>
<span class='kw'>let</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>Primes</span>::<span class='ident'>all</span>().<span class='ident'>take_while</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> <span class='op'>*</span><span class='ident'>p</span> <span class='op'>&lt;</span> <span class='ident'>LIMIT</span>).<span class='ident'>count</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;there are {} primes below 1 million&quot;</span>, <span class='ident'>count</span>); <span class='comment'>// 78498</span>

<span class='comment'>// sieves</span>
<span class='kw'>let</span> <span class='ident'>sieve</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>Sieve</span>::<span class='ident'>new</span>(<span class='ident'>LIMIT</span>);
<span class='kw'>let</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='ident'>sieve</span>.<span class='ident'>prime_pi</span>(<span class='ident'>LIMIT</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;there are {} primes below 1 million&quot;</span>, <span class='ident'>count</span>);

<span class='kw'>let</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>StreamingSieve</span>::<span class='ident'>prime_pi</span>(<span class='ident'>LIMIT</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;there are {} primes below 1 million&quot;</span>, <span class='ident'>count</span>);</pre>

<p><code>StreamingSieve</code> is fastest (380 microseconds) followed by <code>Sieve</code>
(400) with <code>Primes</code> bringing up the rear at 1300 microseconds. Of
course, repeated queries will be faster with <code>Sieve</code> than with
<code>StreamingSieve</code>, but that flexibility comes at the cost of extra
memory use.</p>

<p>If an approximation is all that is required, <code>estimate_prime_pi</code>
provides close upper and lower bounds:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>lo</span>, <span class='ident'>hi</span>) <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>estimate_prime_pi</span>(<span class='number'>1_000_000</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;there are between {} and {} primes below 1 million&quot;</span>, <span class='ident'>lo</span>, <span class='ident'>hi</span>);
<span class='comment'>// 78304, 78573</span></pre>

<h2 id='searching-primes' class='section-header'><a href='#searching-primes'>Searching Primes</a></h2>
<p>Now for something where <code>Primes</code> might be useful: find the first
prime where the binary expansion (not including trailing zeros)
ends like <code>00..001</code> with at least 27 zeros. This condition is
checked by:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>check</span>(<span class='ident'>p</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='ident'>p</span> <span class='op'>&gt;</span> <span class='number'>1</span> <span class='op'>&amp;&amp;</span> (<span class='ident'>p</span> <span class='op'>/</span> <span class='number'>2</span>).<span class='ident'>trailing_zeros</span>() <span class='op'>&gt;=</span> <span class='number'>27</span>
}</pre>

<p>I have no idea how large the prime might be: I know it&#39;s
guaranteed to be at <em>least</em> 2<sup>27 + 1</sup> + 1, but not an
upper limit.</p>

<p>The <code>Primes</code> iterator works perfectly for this:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>Primes</span>::<span class='ident'>all</span>().<span class='ident'>find</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> <span class='ident'>check</span>(<span class='op'>*</span><span class='ident'>p</span>)).<span class='ident'>unwrap</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;the prime is {}&quot;</span>, <span class='ident'>p</span>);</pre>

<p>It takes about 3.1 seconds for my computer to spit out 3,221,225,473.</p>

<p>Using a sieve is a little trickier: one approach is to start with
some estimated upper bound (like double the absolute lower bound),
look for a valid prime. If one isn&#39;t found, double the upper bound
and start again. The <code>primes_from</code> method allows for saving a
little bit of work: we can start iterating from an arbitrary point
in the sequence, such as the lower bound.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>p</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>lower_bound</span> <span class='op'>=</span> <span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='number'>27</span> <span class='op'>+</span> <span class='number'>1</span>);
<span class='kw'>loop</span> {
    <span class='comment'>// our upper bound is double the lower bound</span>
    <span class='kw'>let</span> <span class='ident'>sieve</span> <span class='op'>=</span> <span class='ident'>primal</span>::<span class='ident'>Sieve</span>::<span class='ident'>new</span>(<span class='ident'>lower_bound</span> <span class='op'>*</span> <span class='number'>2</span>);
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>p_</span>) <span class='op'>=</span> <span class='ident'>sieve</span>.<span class='ident'>primes_from</span>(<span class='ident'>lower_bound</span>).<span class='ident'>find</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> <span class='ident'>check</span>(<span class='op'>*</span><span class='ident'>p</span>)) {
        <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>p_</span>;
        <span class='kw'>break</span>
    }
    <span class='ident'>lower_bound</span> <span class='op'>*=</span> <span class='number'>2</span>;
}
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;the prime is {}&quot;</span>, <span class='ident'>p</span>);</pre>

<p>This takes around 3.5 seconds to print the same number. Slower
than the iterator!</p>

<p>I was just using this silly condition as an example of something
that doesn&#39;t have an obvious upper bound, rather than a problem
that is hard to do fast. There&#39;s a much faster way to tackle it,
by inverting the problem: construct numbers that satisfy <code>check</code>,
and check the primality of those.</p>

<p>The numbers that satisfy <code>check</code> are <code>k * (1 &lt;&lt; (27 + 1)) + 1</code> for
<code>k &gt;= 1</code>, so the only hard bit is testing primality. Fortunately,
<code>primal</code> offers the <code>is_prime</code> function which is an efficient way
to do primality tests, even of very large numbers.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>for</span> <span class='ident'>k</span> <span class='kw'>in</span> <span class='number'>1</span>.. {
    <span class='ident'>p</span> <span class='op'>=</span> <span class='ident'>k</span> <span class='op'>*</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='number'>27</span> <span class='op'>+</span> <span class='number'>1</span>)) <span class='op'>+</span> <span class='number'>1</span>;
    <span class='kw'>if</span> <span class='ident'>primal</span>::<span class='ident'>is_prime</span>(<span class='ident'>p</span>) { <span class='kw'>break</span> }
}
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;the prime is {}&quot;</span>, <span class='ident'>p</span>);</pre>

<p>This takes 6 <em>micro</em>seconds: more than 500,000&times;
faster than the iterator!</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Primes.html'
                                  title='primal::Primes'>Primes</a></td>
                           <td class='docblock short'>
                                <p>An iterator over all primes.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.Sieve.html'
                                  title='primal::Sieve'>Sieve</a></td>
                           <td class='docblock short'>
                                <p>A heavily optimised prime sieve.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.SievePrimes.html'
                                  title='primal::SievePrimes'>SievePrimes</a></td>
                           <td class='docblock short'>
                                <p>An iterator over the primes stored in a <code>Sieve</code> instance.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='struct' href='struct.StreamingSieve.html'
                                  title='primal::StreamingSieve'>StreamingSieve</a></td>
                           <td class='docblock short'>
                                <p>A heavily optimised prime sieve.</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.as_perfect_power.html'
                                  title='primal::as_perfect_power'>as_perfect_power</a></td>
                           <td class='docblock short'>
                                <p>Returns integers <code>(y, k)</code> such that <code>x = y^k</code> with <code>k</code> maximised
(other than for <code>x = 0, 1</code>, in which case <code>y = x</code>, <code>k = 1</code>).</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.as_prime_power.html'
                                  title='primal::as_prime_power'>as_prime_power</a></td>
                           <td class='docblock short'>
                                <p>Return <code>Some((p, k))</code> if <code>x = p^k</code> for some prime <code>p</code> and <code>k &gt;= 1</code>
(that is, including when <code>x</code> is itself a prime).</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.estimate_nth_prime.html'
                                  title='primal::estimate_nth_prime'>estimate_nth_prime</a></td>
                           <td class='docblock short'>
                                <p>Gives estimated bounds for <em>p<sub>n</sub></em>, the <code>n</code>th prime number,
1-indexed (i.e. <em>p<sub>1</sub></em> = 2, <em>p<sub>2</sub></em> = 3).</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.estimate_prime_pi.html'
                                  title='primal::estimate_prime_pi'>estimate_prime_pi</a></td>
                           <td class='docblock short'>
                                <p>Returns estimated bounds for π(<em>n</em>), the number of primes less
than or equal to <code>n</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='fn' href='fn.is_prime.html'
                                  title='primal::is_prime'>is_prime</a></td>
                           <td class='docblock short'>
                                <p>Test if <code>n</code> is prime, using the deterministic version of the
Miller-Rabin test.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "primal";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>